 现状速览

  - 技术栈：Vue 3 + Vue CLI 5（Webpack 5）；多页应用（pages: index/sdp_app）；微前端 qiankun。
  - 常见大体积依赖：element-plus、vxe-table、echarts、bpmn-js、dhtmlx-gantt、wangeditor、@fullcalendar/*、logicflow、@vue-office/pdf 等。
  - 构建侧：已配置 splitChunks、多组 cacheGroups、terser 压缩、gzip/br 压缩、IgnorePlugin(moment locales)、runtimeChunk single、deterministic ids、
    文件系统缓存，已具备较好基础。
  - 路由懒加载完善：src/router/index.js 大量使用动态 import 拆路由块。
  - 明显可优化点：
      - lodash 通过 ProvidePlugin 注入为全局 _；多处直接 import _ from 'lodash'；无法 tree-shake，整包进入 vendors。
      - moment 与 dayjs 并存；moment 仍在多处使用，且大量日期处理集中在 src/utils/date_util.js。
      - vxe-table 与 vxe-pc-ui 在入口全局引入（src/main.ts:11-18 与 useTable）；导致 vxe 相关无法落入异步分组（vue.config.js 的 vxeTable cacheGroup
    配了 chunks: 'async'，但入口使用属于 initial chunk，分组失效）。
      - echarts 多处直接 import * as echarts from 'echarts'（全量打包）。
      - 首屏静态资源直引：public/index.html 中 tribute.css/js，public/sdp_app.html 中 mammoth.browser.js（约 1.2MB）与 xml2Json.js；会影响首屏与主包
    缓存策略。
      - browserslist 偏宽（>1%, last 2 versions, not dead），会造成额外转译与 polyfill 负担，且未开启现代构建。
      - 还有少量潜在点：viewerjs 直引、图表/流程编辑器相关 CSS 全量引入、iconfont 全站直引。

  优先优化建议

  1. 大幅减包：替换 lodash 使用方式

  - 问题：ProvidePlugin 注入 _（vue.config.js: chainWebpack -> plugin('provide')）与各处 import _ from 'lodash' 会把 lodash 整包进入初始 vendors，
    tree-shaking 失效。
  - 方案（择一或组合）：
      1. 全量迁移到 lodash-es：在用到的文件处按需导入，如 import { findIndex, cloneDeep } from 'lodash-es'；移除 ProvidePlugin 的 _ 注入；src/shims-
      vue.d.ts 里的全局 _ 类型可删除或改造。
      2. 若不能用 lodash-es，则使用子路径导入：import findIndex from 'lodash/findIndex'、import cloneDeep from 'lodash/cloneDeep'。
      3. 可选：接入 babel-plugin-lodash 做转换（需安装依赖）。
  - 代码触达示例：
      - src/store/index.js:3 改为 import findIndex from 'lodash/findIndex'，并替换 _.findIndex 为 findIndex（其余 _.xxx 逐步替换）。
      - src/axios/fetch.ts:23 里的 _ 来源依赖 ProvidePlugin，可改为 import { isArray } from 'lodash-es' 并替换。
  - 影响：通常可减百 KB 以上（gzip 后仍明显）。

  2. 统一日期库：从 moment 迁移到 dayjs

  - 问题：moment 与 dayjs 并存；moment 仍在多处使用（如 src/utils/date_util.js、多个 gantt 组件）；尽管通过 IgnorePlugin 去掉了 locales，moment 本体
    仍较大。
  - 方案：用 dayjs + plugin（duration、isSame/isBefore/isAfter、weekOfYear、customParseFormat、utc 等）替代；提供适配函数维持原方法签名，逐步替换。
  - 触达文件举例：
      - src/utils/date_util.js:67/77/89/102/109/135... 等全部 moment API；优先替换纯格式化与加减计算路径。
      - 组件模板中的 {{ moment(xxx).format(...) }} 替换为计算属性/方法，用 dayjs 输出。
  - 影响：进一步缩小 vendors 包体；统一维护成本。

  3. vxe-table 与 vxe-pc-ui 按需/延迟加载

  - 问题：入口全局注册（src/main.ts）使得 vxe 相关进入首屏初始 chunk，vue.config.js 的 cacheGroup vxeTable(chunks:'async')无法生效。
  - 方案：
      - 从入口移除全局 .use(VXETable).use(VxeUI)。在实际使用到的路由或组件中，改为异步加载与局部注册：
      - 路由层面：将使用 vxe 的页面拆到子块；页面组件内部 onMounted 才 `const { default: VXETable } = await import('vxe-table')` 并 `app.use(...)`
    或局部注册表格组件。
      - 或使用 vxe-table/es 按需导入所需模块与样式。
  - 影响：明显降低首屏体积与初始化时间；让 splitChunks 的 vxeTable 分组真正落入异步块。

  4. ECharts 模块化引入

  - 问题：多处 import * as echarts from 'echarts'（如 src/components/charts/kLine.vue:14、kMap.vue:17、KEchart.vue:6、features/* 等），全量打入。
  - 方案：使用 echarts/core + 按需组件：
      - 例：
      import { Chart, registerTheme } from 'echarts/core'
      import { LineChart, BarChart } from 'echarts/charts'
      import { GridComponent, TooltipComponent, LegendComponent } from 'echarts/components'
      import { CanvasRenderer } from 'echarts/renderers'
      Chart.use([LineChart, BarChart, GridComponent, TooltipComponent, LegendComponent, CanvasRenderer])
  - 同步调整初始化代码从 echarts.init 切换为 Chart.init 或保留原 api 方式调用。
  - 影响：常见能减少几十到上百 KB（gzip 后仍有收益）。

  5. 首屏资源搬迁为按需加载

  - public/index.html
      - 现有：<link rel="stylesheet" href="./tribute.css"> 和 <script src="./tribute.js">
      - 方案：移除这两行；在使用 @ 提及功能的组件中改为 npm 包 tributejs 或 vue-tribute 按需异步导入和注入 CSS。示例：已存在 src/components/
    jsonSchema/TokenChat/index.vue 使用 new Tribute(...)，可统一迁移。
  - public/sdp_app.html
      - 现有：<script src="./mammoth.browser.js"></script>（1.2MB）
      - 方案：从 HTML 移除；在需要 docx 预览/解析的组件里动态加载：
      const Mammoth = await import(/* webpackChunkName: "mammoth" */ 'mammoth/mammoth.browser');
  - 若解析耗时，可考虑 Web Worker 化，避免主线程卡顿。
  - 影响：显著减小初始请求体积与提高首屏速度，避免“全站都背着少数页面才用的库”。

  6. browserslist 与现代构建

  - 现状：.browserslistrc 为 >1%, last 2 versions, not dead；babel.config.js 默认 preset。
  - 方案：
      - 调整浏览器目标，去掉低价值老环境，如 >= 0.5%, last 2 versions, not dead, not IE 11, not op_mini all，或结合你们的用户画像进一步收紧。
      - 使用 Vue CLI 的现代构建（vue-cli-service build --modern）输出双产物（module/nomodule），现代浏览器拿更小更快的包。需验证 qiankun 子应用场景
    中 HTML 注入策略；一般可工作，但建议先在预发验证。
  - 影响：现代浏览器体积显著下降，执行更快。

  7. 精准预取/预加载策略

  - 现状：全局禁用了 prefetch/preload（vue.config.js: chainWebpack 删除 prefetch/preload）。
  - 方案：
      - 建议不要全局打开 prefetch（会把路由异步块全部预取），但可以对“高频下一跳页面”显式增加 /* webpackPrefetch: true */ 的动态 import 注释，提升二
    跳体验。
      - 对首屏关键路径的小块可用 /* webpackPreload: true */ 谨慎标注。
  - 影响：在带宽充裕场景显著提升二跳速度，同时避免预取风暴。

  8. viewerjs、FullCalendar 等在组件内按需异步加载

  - viewerjs：src/components/tables.vue:281-282 直接 import，可改为在需要预览时动态 import，并仅在首次使用时注入 CSS。
  - FullCalendar：目前仅在日历组件内静态导入，且这些组件为路由懒加载页面，已较好。但可进一步将 FullCalendar 的 import 延后到 onMounted，或拆子组件，
    进一步细化 chunk。

  9. iconfont 全站引入评估

  - public/index.html 与 public/sdp_app.html 引入 iconfont.css，对应字体文件（svg/ttf/woff 等）较大（public/iconfont.* 与 src/assets/font/*）。
  - 方案：
      - 评估是否可用 Element Plus 图标库或 SVG 雪碧图替代一部分通用图标，从而移除或拆分这份自定义 iconfont。
      - 如果必须保留，考虑按路由/业务划分不同字体集以减小单文件体积。
  - 影响：在大量迁移到 SVG 的情况下，能减少几十到几百 KB。

  10. 运行时小建议（易实施）

  - axios/retry：对易失败接口增加轻量重试与超时取消，减少用户等待（用户感知优化）。
  - 大表格虚拟滚动：你们已使用 vxe-table，建议全面开启虚拟滚动/懒加载（若未开启的表格），并限制默认可见列。
  - 事件节流/防抖：滚动、窗口 resize、鼠标拖拽等热点事件确认已节流；lodash-es 的 throttle/debounce 即可。
  - 图片：大图尽量用现代格式（webp/avif），或使用 CDN 自适应裁剪；现 repo 下图体积不算大，但 notfound.gif(944KB) 可考虑 webp 动图或逐帧替代。

  可直接修改的关键位置与建议变更

  - vue.config.js: 取消 ProvidePlugin 注入 lodash；优化 splitChunks 生效前提（把入口 vxe-table 全局引入移走）
      - 文件：vue.config.js
      - 变更点：
      - 删除 ProvidePlugin 中 `_` 注入；保留 utils/filterFormat/dealDate 视具体使用。
      - 保留现有 cacheGroups；让 vxeTable、echarts 等按需落入异步块。
  - src/main.ts: 移除 .use(VXETable).use(VxeUI)，并在使用表格的路由页面内局部/异步注册
      - 文件：src/main.ts:10-18, 33-39
  - lodash 改造（示例）
      - 文件：src/store/index.js:3, 28, 54
      - 替换为：
      import findIndex from 'lodash/findIndex'
      // 使用 findIndex(...) 代替 _.findIndex(...)
  - echarts 模块化（示例）
      - 文件：src/components/charts/kLine.vue:14
      - 替换为 echarts/core 按需引入（见上方案）。
  - moment -> dayjs（示例）
      - 文件：src/utils/date_util.js:67, 77, 89, 102, 109, 135...
      - 替换为 dayjs + plugins，保持函数输出不变。
  - 首屏资源搬迁
      - public/index.html：移除 tribute.css/js；在用到的组件动态加载。
      - public/sdp_app.html：移除 mammoth.browser.js 与 xml2Json.js；在用到的组件动态加载并加 chunkName。

  可选方向（视你们时间）

  - 迁移到 Vite：更快的构建/热更体验，rollup 的 tree-shaking 通常更干净；但与 qiankun 子应用需要做少量适配（publicPath、libraryTarget 等）。
  - 进一步使用 CDN externals：例如 echarts、moment/dayjs、vxe-table、element-plus 放 CDN 并通过 externals 剥离；微前端环境需考虑依赖共享与版本一
    致性。

  建议的推进顺序

  1. 移除首屏直引（mammoth、tribute），验证首屏时间与 chunk 划分变化。
  2. vxe-table 从入口移除并页面内按需异步注册；观察 vendors 体积与首包体积变化。
  3. lodash 改造为按需导入（先从核心文件开始：store、axios、utils 与高频页面）。
  4. echarts 模块化引入。
  5. moment -> dayjs 渐进迁移。
  6. 评估是否开启现代构建与收紧 browserslist。
  7. 补上关键路由的精确 prefetch。

  需要我先从哪一条开始动手？建议从 1、2、3 三项开始，收益最大且风险低。