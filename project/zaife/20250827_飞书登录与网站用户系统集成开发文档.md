飞书登录与网站用户系统集成开发文档

  项目概述

  本项目实现了飞书OAuth授权登录与网站现有用户系统的深度集成，支持新用户自动注册绑定和老用户直接登录的完整业务流程
  。

  技术架构

  前端技术栈

  - Vue 2.x - 主框架
  - Element UI - UI组件库
  - 飞书h5-js-sdk-1.5.42 - 飞书官方SDK
  - 飞书远程调试工具 - remote-debug-0.0.1-alpha.6

  核心文件结构

  /Users/peakom/Documents/work/zai-fe/
  ├── client/
  │   ├── index.html                    # SDK加载和远程调试配置
  │   └── src/pages/feishu/auth.vue     # 主业务逻辑文件
  └── 相关配置文件

  业务流程设计

  整体用户体验流程

  graph TD
      A[用户点击飞书登录] --> B[飞书OAuth授权]
      B --> C[获取authorization code]
      C --> D[换取用户OpenID]
      D --> E[尝试登录]
      E --> F{用户是否已注册}
      F -->|是| G[直接登录成功]
      F -->|否| H[显示手机号绑定界面]
      H --> I[用户输入手机号]
      I --> J[发送短信验证码]
      J --> K[用户输入验证码]
      K --> L[可选输入邀请码]
      L --> M[提交绑定信息]
      M --> N[绑定成功并登录]
      G --> O[跳转到目标页面]
      N --> O

  状态机设计

  const AUTH_STATES = {
    LOADING: 'loading',        // SDK加载中
    CHECKING: 'checking',      // 检查登录状态
    NEED_BINDING: 'needBinding', // 需要绑定手机号
    BINDING: 'binding',        // 绑定中
    SUCCESS: 'success',        // 登录成功
    ERROR: 'error'            // 出现错误
  };

  接口设计规范

  1. 获取AppID接口

  GET /api/user/getfsappid

  响应格式:
  {
    "errno": 0,
    "data": {
      "appId": "cli_a80e6f280e3b500c"
    }
  }

  说明:
  - 安全考虑，AppID不在前端硬编码
  - 前端优先使用服务端返回的AppID
  - 失败时使用fallback机制

  2. 获取用户信息接口

  POST /api/isv/feishu/getuserinfo
  Content-Type: application/json

  {
    "code": "飞书授权码"
  }

  成功响应:
  {
    "errno": 0,
    "data": {
      "openID": "ou_29bfeae5cea25e534f3ce2b1c3067add",
      "unionID": "on_xxx",
      "avatarUrl": "https://...",
      "name": "用户名",
      "en_name": "English Name"
    }
  }

  常见错误:
  {
    "errno": 130356,
    "msg": "权限飞朽期应用limit app_access_token失效"
  }

  3. 登录/绑定统一接口

  POST /api/user/fsreglogin
  Content-Type: application/json

  场景1: 已注册用户直接登录
  // 请求
  {
    "openID": "ou_29bfeae5cea25e534f3ce2b1c3067add"
  }

  // 成功响应
  {
    "errno": 0,
    "data": {
      "token": "jwt_token_here",
      "userInfo": {
        "userId": "123",
        "name": "用户名",
        "avatar": "头像URL"
      }
    }
  }

  场景2: 新用户需要绑定
  // 请求 (同场景1)
  {
    "openID": "ou_29bfeae5cea25e534f3ce2b1c3067add"
  }

  // 需要绑定响应
  {
    "errno": 3001,
    "msg": "用户不存在，需要绑定手机号"
  }

  场景3: 绑定手机号注册
  // 请求
  {
    "openID": "ou_29bfeae5cea25e534f3ce2b1c3067add",
    "isBinding": 1,
    "mobile": "13800138000",
    "code": "123456",
    "referrerPin": "邀请码(可选)"
  }

  // 成功响应 (同场景1)
  {
    "errno": 0,
    "data": {
      "token": "jwt_token_here",
      "userInfo": {...}
    }
  }

  4. 发送短信验证码接口

  POST /api/user/getreglogincode
  Content-Type: application/json

  {
    "mobile": "13800138000"
  }

  成功响应:
  {
    "errno": 0,
    "msg": "验证码已发送"
  }

  前端实现详解

  核心组件结构

  1. 数据结构设计

  data() {
    return {
      // 认证状态
      authState: AUTH_STATES.LOADING,

      // 飞书相关数据
      openID: '',
      code: '', // 飞书授权码
    
      // 绑定表单
      bindingForm: {
        mobile: '',
        code: '',
        referrerPin: ''
      },
    
      // UI状态
      hasReferrerPin: false,
      agreement: true,
      isSendingCode: false,
      countdown: 60,
    
      // 调试信息 - 关键特性
      debugInfo: {
        // SDK状态
        sdkLoaded: false,
        hasTt: false,
        hasH5sdk: false,
        hasRemoteDebug: false,
    
        // 接口调用状态
        getAppIdStatus: '',      // success/error/''
        getAppIdResult: '',      // 结果描述
        getAppIdResponse: null,  // 完整响应JSON
        getAppIdRequest: null,   // 完整请求JSON
    
        getUserInfoStatus: '',
        getUserInfoResult: '',
        getUserInfoRequest: null,
    
        // 错误信息
        lastError: '',
        lastResponse: null
      }
    };
  }

  2. 关键方法实现

  SDK初始化和检测:
  async waitForFeishuSDK() {
    return new Promise((resolve, reject) => {
      let retryCount = 0;
      const checkSDK = () => {
        if (window.h5sdk && window.tt && window.tt.requestAccess) {
          resolve();
        } else if (retryCount < 100) {
          retryCount++;
          setTimeout(checkSDK, 100);
        } else {
          reject(new Error('飞书SDK加载超时'));
        }
      };
      checkSDK();
    });
  }

  获取AppID (支持fallback):
  async fetchAppId() {
    try {
      // 优先从服务端获取
      const result = await util.request({
        url: '/api/user/getfsappid',
        method: 'GET'
      });

      if (result?.errno === 0 && result.data?.appId) {
        return result.data.appId;
      }
    } catch (error) {
      console.error('服务端获取AppID失败:', error);
    }
    
    // fallback到硬编码
    return 'cli_a80e6f280e3b500c';
  }

  飞书授权核心逻辑:
  async callFeishuAuthAPI(appId) {
    return new Promise((resolve, reject) => {
      // 检查环境和SDK
      if (!window.h5sdk) {
        reject(new Error('请在飞书客户端中打开'));
        return;
      }

      // 按官方文档设置错误回调
      window.h5sdk.error(err => {
        reject(new Error('h5sdk error: ' + JSON.stringify(err)));
      });
    
      // SDK就绪后调用授权
      window.h5sdk.ready(() => {
        window.tt.requestAccess({
          appID: appId,
          scopeList: [],
          success: (res) => {
            this.code = res.code;
            resolve(res.code);
          },
          fail: (err) => {
            // 特殊处理权限错误
            if (err.errno === 2700002 && err.errString?.includes('20010')) {
              this.logAppPermissionInfo(appId);
            }
            reject(new Error(err.errString || '授权失败'));
          }
        });
      });
    });
  }

  统一登录处理:
  async attemptLogin() {
    try {
      const result = await util.request({
        url: '/api/user/fsreglogin',
        method: 'POST',
        data: { openID: this.openID }
      });

      if (result.errno === 0) {
        // 登录成功 - 保存用户信息
        this.saveUserSession(result.data);
        this.handleSuccess();
      } else if (result.errno === 3001) {
        // 需要绑定手机号
        this.authState = AUTH_STATES.NEED_BINDING;
      } else {
        // 其他错误
        const errorInfo = getErrorInfo(result.errno);
        this.handleError(errorInfo.title, errorInfo.message);
      }
    } catch (error) {
      this.handleError('登录失败', error.message);
    }
  }

  手机号绑定处理:
  async handleBinding() {
    if (!this.agreement) {
      util.message('warning', '请先同意用户协议');
      return;
    }

    await this.$refs.bindingForm.validate();
    this.authState = AUTH_STATES.BINDING;
    
    const result = await util.request({
      url: '/api/user/fsreglogin',
      method: 'POST',
      data: {
        openID: this.openID,
        isBinding: 1,
        mobile: this.bindingForm.mobile,
        code: this.bindingForm.code,
        referrerPin: this.bindingForm.referrerPin
      }
    });
    
    if (result.errno === 0) {
      util.message('success', '绑定成功！');
      this.saveUserSession(result.data);
      this.handleSuccess();
    } else {
      this.authState = AUTH_STATES.NEED_BINDING;
      util.message('error', result.msg || '绑定失败');
    }
  }

  3. UI界面设计

  主要状态界面

  加载状态:
  <div v-if="authState === 'loading'" class="loading-panel">
    <div class="spinner">...</div>
    <div class="loading-text">{{ loadingText }}</div>
  </div>

  绑定手机号界面:
  <div v-else-if="authState === 'needBinding'" class="binding-panel">
    <el-form :model="bindingForm" :rules="bindingRules">
      <!-- 手机号输入 -->
      <el-form-item prop="mobile">
        <el-input placeholder="请输入手机号" v-model="bindingForm.mobile"/>
      </el-form-item>

      <!-- 验证码输入 -->
      <el-form-item prop="code">
        <el-input placeholder="请输入验证码" v-model="bindingForm.code">
          <template #append>
            <el-button
              :disabled="isSendingCode"
              @click="sendVerificationCode"
            >
              {{ isSendingCode ? `${countdown}s` : '发送验证码' }}
            </el-button>
          </template>
        </el-input>
      </el-form-item>
    
      <!-- 邀请码(可选) -->
      <el-form-item prop="referrerPin">
        <el-checkbox v-model="hasReferrerPin">使用邀请码</el-checkbox>
        <el-input
          v-if="hasReferrerPin"
          placeholder="请输入邀请码"
          v-model="bindingForm.referrerPin"
        />
      </el-form-item>
    
      <!-- 用户协议 -->
      <el-checkbox v-model="agreement">
        我已阅读并同意
        <a href="/info/agreement" target="_blank">《用户协议》</a>
        <a href="/info/privacy" target="_blank">《隐私政策》</a>
      </el-checkbox>
    
      <!-- 提交按钮 -->
      <el-button
        type="primary"
        :loading="authState === 'binding'"
        @click="handleBinding"
      >
        {{ authState === 'binding' ? '绑定中...' : '立即绑定' }}
      </el-button>
    </el-form>
  </div>

  调试信息界面 (开发重要特性):
  <div class="debug-info">
    <!-- SDK状态 -->
    <div class="debug-item">
      <span class="debug-label">SDK状态:</span>
      <span class="debug-value" :class="debugInfo.sdkLoaded ? 'success' : 'error'">
        {{ debugInfo.sdkLoaded ? '已加载' : '未加载' }}
      </span>
    </div>

    <!-- 接口调用详情 -->
    <div class="debug-item">
      <span class="debug-label">AppID接口:</span>
      <span class="debug-value" :class="debugInfo.getAppIdStatus">
        {{ debugInfo.getAppIdResult || '未调用' }}
      </span>
    </div>
    
    <!-- 完整的请求响应信息 -->
    <div class="debug-item" v-if="debugInfo.getAppIdRequest">
      <span class="debug-label">AppID请求:</span>
      <div class="debug-response">{{ debugInfo.getAppIdRequest }}</div>
    </div>
    
    <div class="debug-item" v-if="debugInfo.getAppIdResponse">
      <span class="debug-label">AppID响应:</span>
      <div class="debug-response">{{ debugInfo.getAppIdResponse }}</div>
    </div>
  </div>

  4. SDK配置 (client/index.html)

  多CDN加载策略:
  <script>
  (function() {
    const SDK_URLS = [
      'https://lf1-cdn-tos.bytegoofy.com/goofy/lark/op/h5-js-sdk-1.5.42.js',
      'https://sf1-scmcdn-tos.pstatp.com/goofy/lark/op/h5-js-sdk-1.5.42.js',
      'https://lf3-cdn-tos.bytescm.com/goofy/lark/op/h5-js-sdk-1.5.42.js'
    ];

    function loadSDK(urls, index = 0) {
      if (index >= urls.length) return;
    
      const script = document.createElement('script');
      script.src = urls[index];
      script.onload = () => console.log('SDK加载成功:', urls[index]);
      script.onerror = () => loadSDK(urls, index + 1);
      document.head.appendChild(script);
    }
    
    loadSDK(SDK_URLS);
  })();
  </script>

  远程调试工具:
  <script
    src='https://lf-package-cn.feishucdn.com/obj/feishu-static/op/fe/devtools_frontend/remote-debug-0.0.1-alpha.6
  .js'
    onload="console.log('✅ 远程调试工具加载成功'); window.FEISHU_REMOTE_DEBUG_LOADED = true;"
    onerror="console.error('❌ 远程调试工具加载失败'); window.FEISHU_REMOTE_DEBUG_LOADED = false;"
  ></script>

  调试和排错机制

  1. 分层调试信息

  Console日志分类:
  // SDK检测日志
  console.log('=== 开始检测飞书SDK ===');
  console.log('SDK状态检查:', status);

  // 接口调用日志
  console.log('=== AppID接口调用 ===');
  console.log('请求:', request);
  console.log('响应:', response);

  // 权限错误分析
  console.log('=== 权限错误分析 ===');
  console.log('错误类型: 当前用户无该应用权限');
  console.log('建议解决方案: 联系管理员添加测试用户');

  页面调试面板:
  - 实时显示SDK加载状态
  - 完整的接口请求和响应信息
  - 错误详情和解决建议
  - 用户身份和权限信息

  2. 常见问题和解决方案

| 问题类型    | 错误信息       | 原因分析             | 解决方案               |
| ----------- | -------------- | -------------------- | ---------------------- |
| SDK加载失败 | h5sdk未加载    | 网络问题/CDN访问失败 | 多CDN重试机制          |
| 权限错误    | errno: 2700002 | 用户无应用权限       | 添加测试用户到飞书后台 |
| Token过期   | errno: 130356  | app_access_token过期 | 后端刷新token          |
| 绑定失败    | errno: 其他    | 手机号/验证码错误    | 检查输入信息           |

  3. 性能监控

  // 关键节点性能监控
  perfMonitor.mark('auth_start');
  perfMonitor.mark('sdk_ready');
  perfMonitor.mark('auth_success');

  // 计算耗时
  perfMonitor.measure('total_auth_time', 'auth_start', 'auth_success');

  部署和配置

  1. 飞书开发者后台配置

  必需配置项:
  - 应用ID: cli_a80e6f280e3b500c
  - 重定向URI: http://local.zizai.work:8058/feishu/auth
  - 权限范围: 获取用户基本信息
  - 测试用户: 添加开发测试账号

  可见范围设置:
  - 企业内部应用：配置可见部门/用户
  - 应用商店应用：配置发布范围

  2. 服务端要求

  接口实现清单:
  - GET /api/user/getfsappid - 返回应用ID
  - POST /api/isv/feishu/getuserinfo - 获取用户信息
  - POST /api/user/fsreglogin - 登录/绑定统一接口
  - POST /api/user/getreglogincode - 发送短信验证码

  安全要求:
  - app_access_token定期刷新机制
  - 短信验证码防刷机制
  - 用户数据加密存储

  3. 环境要求

  运行环境:
  - HTTPS协议 (飞书SDK要求)
  - 域名在飞书应用白名单中
  - 支持跨域请求的后端配置

  用户体验优化

  1. 加载体验

  // 渐进式加载提示
  const loadingMessages = [
    '正在验证身份...',
    '获取授权码...',
    '获取用户信息...',
    '正在登录...'
  ];

  // 根据当前步骤显示对应提示
  this.loadingText = loadingMessages[currentStep];

  2. 错误友好提示

  // 用户友好的错误信息映射
  const ERROR_MESSAGES = {
    130356: {
      title: 'Token过期',
      message: '系统繁忙，请稍后重试',
      action: '联系技术支持刷新token'
    },
    2700002: {
      title: '权限不足',
      message: '当前账号无法使用此功能',
      action: '联系管理员开通权限'
    }
  };

  3. 响应式适配

  // 移动端适配
  @media (max-width: 768px) {
    .binding-panel {
      padding: 30px 20px;
      margin: 10px;
    }

    .debug-info {
      font-size: 12px;
      .debug-item {
        flex-direction: column;
      }
    }
  }

  数据流和状态管理

  1. 全局状态

  // 登录成功后设置全局用户状态
  window.ZAI = window.ZAI || {};
  window.ZAI.user = {
    isLogin: true,
    userId: userData.userId,
    name: userData.name,
    avatar: userData.avatar,
    openID: this.openID // 保存飞书OpenID用于后续接口调用
  };

  2. 本地存储策略

  // Token存储
  localStorage.setItem('auth_token', userData.token);
  localStorage.setItem('user_info', JSON.stringify(userData.userInfo));

  // 飞书相关信息存储
  sessionStorage.setItem('feishu_openid', this.openID);
  sessionStorage.setItem('feishu_auth_time', Date.now());

  3. 页面跳转逻辑

  handleSuccess() {
    this.authState = AUTH_STATES.SUCCESS;

    // 1秒后跳转，给用户成功反馈时间
    setTimeout(() => {
      const redirectUrl = this.redirectUrl || '/dashboard';
      window.location.href = redirectUrl;
    }, 1000);
  }

  测试和验证

  1. 功能测试清单

  基础功能:
  - SDK正常加载
  - 获取AppID成功
  - 飞书授权成功获取code
  - code换取OpenID成功

  用户场景:
  - 已注册用户直接登录
  - 新用户显示绑定界面
  - 手机号验证码发送成功
  - 绑定成功并登录
  - 错误情况正确显示

  边界情况:
  - 网络异常处理
  - 权限不足处理
  - Token过期处理
  - 用户取消授权处理

  2. 调试验证方法

  开发者工具检查:
  // 检查SDK加载状态
  console.log('SDK状态:', {
    hasH5sdk: !!window.h5sdk,
    hasTt: !!window.tt,
    hasRequestAccess: !!(window.tt && window.tt.requestAccess)
  });

  // 检查用户状态
  console.log('用户状态:', window.ZAI?.user);

  // 检查存储状态
  console.log('Token:', localStorage.getItem('auth_token'));
  console.log('OpenID:', sessionStorage.getItem('feishu_openid'));

  维护和扩展

  1. 日志收集

  // 关键操作日志记录
  const logAuthEvent = (event, data) => {
    const logData = {
      timestamp: Date.now(),
      event,
      data,
      userAgent: navigator.userAgent,
      url: window.location.href
    };

    // 发送到日志收集服务
    util.request({
      url: '/api/log/auth',
      method: 'POST',
      data: logData
    });
  };

  2. 扩展接入其他登录方式

  // 统一登录管理器
  class AuthManager {
    async login(provider, credentials) {
      switch(provider) {
        case 'feishu':
          return await this.feishuLogin(credentials);
        case 'wechat':
          return await this.wechatLogin(credentials);
        case 'phone':
          return await this.phoneLogin(credentials);
      }
    }
  }

  3. 监控和告警

  关键指标监控:
  - SDK加载成功率
  - 授权成功率
  - 登录成功率
  - 绑定成功率
  - 平均登录耗时

  告警规则:
  - SDK加载失败率 > 5%
  - 权限错误 > 10次/小时
  - Token过期错误 > 5次/小时

---
  开发完成标志

  ✅ 已完成功能

  1. SDK集成：飞书h5-js-sdk完整集成和多重检测
  2. 授权流程：从授权到获取OpenID的完整流程
  3. 用户界面：加载、绑定、成功、错误四种状态界面
  4. 调试系统：完整的页面和console调试信息
  5. 错误处理：各种异常情况的处理和用户友好提示
  6. 安全机制：AppID获取的fallback机制和权限检查

  📋 后续工作

  1. 后端接口联调：确保所有接口按规范实现
  2. 权限配置：飞书开发者后台的用户权限配置
  3. 生产部署：HTTPS环境和域名白名单配置
  4. 用户测试：真实场景的用户体验测试

---
  文档版本: v2.0最后更新: 2025-08-27维护状态: 开发完成，等待联调